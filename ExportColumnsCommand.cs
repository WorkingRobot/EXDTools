using DotMake.CommandLine;
using YamlDotNet.Serialization;
using YamlDotNet.Serialization.NamingConventions;

namespace EXDTooler;

[CliCommand(Parent = typeof(MainCommand))]
public sealed class ExportColumnsCommand
{
    public required MainCommand Parent { get; set; }

    [CliOption(Required = false, Description = "Path to the game directory. Should be the root of the game's repository.", ValidationRules = CliValidationRules.ExistingDirectory)]
    public string? GamePath { get; set; }

    [CliOption(Required = false, Description = "Path to the columns file generated by export-columns.", ValidationRules = CliValidationRules.ExistingFile)]
    public string? ColumnsFile { get; set; }

    [CliOption(Required = false, Description = "Path to the output file.")]
    public string? OutputPath { get; set; }

    public Task RunAsync()
    {
        var token = Parent.Init();

        var schemaSerializer = new SerializerBuilder()
            .DisableAliases()
            .WithNamingConvention(CamelCaseNamingConvention.Instance)
            .WithEnumNamingConvention(LowerCaseNamingConvention.Instance)
            .WithIndentedSequences()
            .EnsureRoundtrip()
            .Build();

        var sheets = ColDefReader.FromInputs(GamePath, ColumnsFile);

        if (OutputPath != null)
        {
            using var f = File.OpenWrite(OutputPath);
            f.SetLength(0);
            using var writer = new StreamWriter(f);
            schemaSerializer.Serialize(writer, sheets.Sheets);
        }
        else
            schemaSerializer.Serialize(Console.Out, sheets.Sheets);

        Log.Info($"Hash: {sheets.HashString}");
        return Task.CompletedTask;
    }
}