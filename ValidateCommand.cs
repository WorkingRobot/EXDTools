using System.Reflection;
using System.Runtime.CompilerServices;
using System.Text;
using DotMake.CommandLine;
using EXDTooler.BreakingValidators;
using EXDTooler.Schema;
using EXDTooler.Validators;
using Json.Schema;
using Lumina;
using Lumina.Data.Files.Excel;
using Lumina.Data.Structs.Excel;
using Yaml2JsonNode;
using YamlDotNet.RepresentationModel;
using YamlDotNet.Serialization;
using YamlDotNet.Serialization.NamingConventions;

namespace EXDTooler;

[CliCommand(Parent = typeof(MainCommand))]
public sealed class ValidateCommand
{
    public required MainCommand Parent { get; set; }

    [CliOption(Required = false, Description = "Path to the game directory. Should be the root of the game's repository.", ValidationRules = CliValidationRules.ExistingDirectory)]
    public string? GamePath { get; set; }

    [CliOption(Required = false, Description = "Path to the columns file generated by export-columns.", ValidationRules = CliValidationRules.ExistingFile)]
    public string? ColumnsFile { get; set; }

    [CliOption(Required = true, Description = "Path to the schema directory. Should be a folder with just .yml schemas.", ValidationRules = CliValidationRules.ExistingDirectory)]
    public required string SchemaPath { get; set; }

    [CliOption(Required = false, Description = "Path to the base schema directory. Should be a folder with just .yml schemas. Used for ensuring no breaking changes occured.", ValidationRules = CliValidationRules.ExistingDirectory)]
    public string? BaseSchemaPath { get; set; }

    [CliOption(Required = false, Description = "Path to a schema.json. If omitted, the built-in one will be used.", ValidationRules = CliValidationRules.ExistingFile)]
    public string? JsonSchemaPath { get; set; }

    // [CliOption(Required = false, Description = "Path to sheetHashes.json file. Contains the hashes of all known sheets in the game in all versions.", ValidationRules = CliValidationRules.ExistingFile)]
    // public string? SheetHashesPath { get; set; }

    [CliOption(Required = false, Description = "List of schema file paths to verify", Arity = CliArgumentArity.OneOrMore, ValidationRules = CliValidationRules.ExistingFile)]
    public string[]? FilesToVerify { get; set; }

    public async Task<int> RunAsync()
    {
        var token = Parent.Init();

        var sheets = ColDefReader.FromInputs(GamePath, ColumnsFile);

        // Dictionary<string, Dictionary<string, uint>>? sheetHashes = null;
        // if (SheetHashesPath is not null)
        // {
        //     using var f = File.OpenRead(SheetHashesPath);
        //     sheetHashes = await JsonSerializer.DeserializeAsync<Dictionary<string, Dictionary<string, uint>>>(f).ConfigureAwait(false);
        // }

        JsonSchema schema;
        if (JsonSchemaPath != null)
            schema = JsonSchema.FromFile(JsonSchemaPath);
        else
        {
            using var s = Assembly.GetExecutingAssembly().GetManifestResourceStream("EXDTooler.schema.json")!;
            schema = await JsonSchema.FromStream(s).ConfigureAwait(false);
        }

        var schemaOptions = new EvaluationOptions
        {
            ValidateAgainstMetaSchema = true,
            RequireFormatValidation = true,
            OutputFormat = OutputFormat.List,
            OnlyKnownFormats = true,
            AllowReferencesIntoUnknownKeywords = false,
        };

        var schemaDeserializer = new DeserializerBuilder().WithNamingConvention(CamelCaseNamingConvention.Instance).Build();

        if (FilesToVerify == null || FilesToVerify.Length == 0)
            FilesToVerify = [.. Directory.EnumerateFiles(SchemaPath, "*.yml")];
        else
            FilesToVerify = [.. FilesToVerify.Select(f => Path.GetFullPath(f, SchemaPath))];
        Log.Verbose($"Verifying {FilesToVerify.Length} files");

        var validatedFiles = 0;
        foreach (var (idx, sheetFile) in FilesToVerify.Index())
        {
            var baseSheetFile = BaseSchemaPath == null ? null : Path.Combine(BaseSchemaPath, Path.GetRelativePath(SchemaPath, sheetFile));
            if (BaseSchemaPath != null && !File.Exists(baseSheetFile))
            {
                Log.Warn($"Cannot verify {Path.GetFileNameWithoutExtension(sheetFile)} for breaking changes. {baseSheetFile} does not exist.");
                baseSheetFile = null;
            }

            if (Validate(sheetFile, sheets, schemaDeserializer, d => schema.Evaluate(d.ToJsonNode(), schemaOptions), baseSheetFile))
                validatedFiles++;

            if ((idx & 3) == 0)
                Log.VerboseProgress($"Verified {validatedFiles}/{idx + 1} files. ({(idx + 1) / (double)FilesToVerify.Length * 100:0.00}% done)");
        }
        Log.VerboseProgressClear();
        Log.Info($"Verified {validatedFiles}/{FilesToVerify.Length} files. ({(FilesToVerify.Length == 0 ? 1 : (validatedFiles / (double)FilesToVerify.Length)) * 100:0.00}%)");
        return validatedFiles == FilesToVerify.Length ? 0 : 1;
    }

    private static bool Validate(string sheetFile, ColDefReader colDefs, IDeserializer schemaDeserializer, Func<YamlDocument, EvaluationResults> evaluateSchema, string? baseSheetFile)
    {
        {
            using var f = File.OpenText(sheetFile);
            var yamlStream = new YamlStream();
            yamlStream.Load(f);
            if (yamlStream.Documents.Count > 1)
            {
                Log.Error($"Multiple documents in {sheetFile} (??)");
                return false;
            }
            var results = evaluateSchema(yamlStream.Documents[0]);
            if (!results.IsValid)
            {
                Log.Error($"Failed to validate {sheetFile}.");
                foreach (var result in results.Details)
                {
                    if (result.IsValid)
                        continue;
                    if (!result.HasErrors)
                        continue;

                    foreach (var error in result.Errors!.Values)
                    {
                        var s = new StringBuilder("  ");
                        if (result.InstanceLocation.Count > 0)
                            s.Append(result.InstanceLocation);
                        else
                            s.Append('/');
                        s.Append(result.EvaluationPath);
                        s.Append(": ");
                        s.Append(error);
                        Log.Error(s.ToString());
                    }
                }
                return false;
            }
        }

        Sheet sheet;
        {
            using var f = File.OpenText(sheetFile);
            sheet = schemaDeserializer.Deserialize<Sheet>(f);
        }
        if (sheet == null)
        {
            Log.Error($"Failed to deserialize {sheetFile}");
            return false;
        }

        if (Path.GetFileNameWithoutExtension(sheet.Name) != sheet.Name)
        {
            Log.Error($"Sheet {sheetFile} does not match its file name");
            return false;
        }

        if (!colDefs.Sheets.TryGetValue(sheet.Name, out var cols))
        {
            Log.Error($"Failed to load {sheet.Name}.exh");
            return false;
        }

        bool[] checks = [
                Validate<ColumnCount>(sheet, cols, colDefs),
                Validate<ColumnTypes>(sheet, cols, colDefs),
                Validate<DisplayField>(sheet, cols, colDefs),
                Validate<LinkConditionType>(sheet, cols, colDefs),
                Validate<LinkSwitchField>(sheet, cols, colDefs),
                Validate<Relations>(sheet, cols, colDefs),
                Validate<SheetRefs>(sheet, cols, colDefs),
            ];

        var pendingChecks = checks;
        if (sheet.PendingFields != null)
        {
            sheet.Fields = sheet.PendingFields;
            pendingChecks = [
                Validate<ColumnCount>(sheet, cols, colDefs),
                    Validate<ColumnTypes>(sheet, cols, colDefs),
                    true,
                    Validate<LinkConditionType>(sheet, cols, colDefs),
                    Validate<LinkSwitchField>(sheet, cols, colDefs),
                    Validate<Relations>(sheet, cols, colDefs),
                    Validate<SheetRefs>(sheet, cols, colDefs),
                ];
        }

        if (checks.Any(x => !x) || pendingChecks.Any(x => !x))
            return false;

        if (baseSheetFile != null)
        {
            Sheet baseSheet;
            {
                using var f = File.OpenText(baseSheetFile);
                baseSheet = schemaDeserializer.Deserialize<Sheet>(f);
            }

            bool[] baseChecks = [
                Validate<FieldNamesAndTypes>(baseSheet, sheet, cols, colDefs)
            ];

            if (!baseChecks.Any(x => x))
                return false;
        }
        return true;
    }

    private static bool Validate<T>(Sheet sheet, List<ExcelColumnDefinition> cols, ColDefReader colDefs) where T : IValidator<T>
    {
        try
        {
            T.Validate(sheet, cols, colDefs);
            return true;
        }
        catch (Exception ex)
        {
            Log.Error($"Failed to validate {sheet.Name} with {typeof(T).Name}: {ex.Message}");
            return false;
        }
    }

    private static bool Validate<T>(Sheet baseSheet, Sheet newSheet, List<ExcelColumnDefinition> cols, ColDefReader colDefs) where T : IBreakingValidator<T>
    {
        try
        {
            T.Validate(baseSheet, newSheet, cols, colDefs);
            return true;
        }
        catch (Exception ex)
        {
            Log.Error($"Failed to validate breaking changes {newSheet.Name} with {typeof(T).Name}: {ex.Message}");
            return false;
        }
    }
}